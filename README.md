# ITSharkAndroidProject
Part 0 and Part 1
1. Создаем новый проект со стартовым экраном EmptyActivity.
LTKM: Основы создания приложений - https://developer.android.com/guide/components/fundamentals.html?hl=ru#body-content

2. Для создания списка, будем использовать RecyclerView. Эта View не входит в стандартный пакет, так что добавим необходимую зависимость в build.gradle файл.

3. Добавим RecyclerView в макет окна - файл-ресурс activity_main.xml.
LTKM: Подробнее о ресурсах приложения: https://developer.android.com/guide/topics/resources/accessing-resources.html?hl=ru
TIP: Id будем задавать в формате <what_where_name>

4. Создадим файл с внешним видом каждого элемента в RecyclerView - adapter_list_item.xml.
TIP: Для названия элементов списка в RecyclerView используется шаблон adapter_<name>_item.

5. Хорошим тоном считается выносить отступы (а так же цвета, и др. ресурсы) в отдельный файл. Поэтому вынесем стандартные отступы 16 (отступ для экрана), и 8 (для контента) в dimen.xml.

6. Добавим необходимые виджеты в файл adapter_list_item.xml.
LTKM: Подробнее о макетах - https://developer.android.com/guide/topics/ui/declaring-layout.html

7. Элементы списка должны выводить имя и описание, а также иметь номер для их идентификации. Для удобства работы создадим класс-модель ListItemModel. Пропишем необходимые поля класса и гет-методы. В рамках этого задания все айтемы имеют одинаковые шаблоны для названия "Item <id>" и описание "This is item <id>". Вынесем эти строки-шаблоны в приватные поля класса, и используем в конструкторе для инициализации полей name, description.
Tip: Воспользуйтесь возможностями среды AndroidStudio. ПКМ -> Generate, и дальше сгенерируйте гет-методы.

8. Для работы RecyclerView необходимы так же 2 сущности - адаптер, который будет контролировать создание и инициализацию внешнего вида каждого элемента в списке. И LayoutManager - отвечает за компоновку элементов (списком, сеткой и т.п.). Сделаем свою реализацию адаптера, для начала создав пустой класс ListAdapter.
LTKM: Подробнее о RecyclerView - https://developer.android.com/training/material/lists-cards.html?hl=ru.

9. Создадим внутренний класс ViewHolder, отнаследовав его от RecyclerView.ViewHolder. Этот класс нужен для реализации адаптера и будет содержать ссылки на вью элемента списка.

10. Пропишем родителя для нашего адаптера - стандартную реализации - RecyclerView.Adapter, в качестве параметра класса, укажем созданный на предыдущем шаге ViewHolder.

11. Создадим объект-список моделей элементов(List<ListItemModel> items).

12. После этого, среда попросит нас перегрузить 3 метода:
- onCreateViewHolder - метод который вызовется при создании элемента в списке. В нем мы предоставляем визуальным представлением элемента (файл adapter_list_item.xml) объекту класса ViewHolder.
- onBindViewHolder - вызывается при отрисовке каждого элемента на экране. Нужен для того что бы инициализировать вью элемента данными из модели.
- getItemCount - метод возвращающий количество элементов списка.

13. Что бы удобно обновить содержимое списка, создадим метод update. В нем обновляем модель списка (item), и уведомляем систему о том что содержимое списка было обновлено и необходимо перерисовать содержимое RecyclerView. За последнее отвечает вызов notifyDataSetChanged.
LTKM: Подробнее о методах обновления списка и самом списке - https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html.

14. Теперь у нас есть все необходимое для показа списка элементов. Создаем метод initList. Для работы RecyclerView создадим менеджер лэйаута - LinearLayoutManager с вертикальной ориентацией. И объект адаптера ListAdapter.
LTKM: Подробнее о LinearLayoutManager - https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html

15. Теперь необходимо передать адаптеру данные элементов списка для отображения. Воспользуемся созданным ранее методом update. На вход дадим результат работы метода initListItemModels.

16. Добавим декоратор для элементов списка. Воспользуемся стандартной реализацией - классом DividerItemDecoration. Декоратор будет добавлять разделяющию линию между элементами списка.
LTKM: Подробнее о DividerItemDecoration - https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemDecoration.html

17. Согласно заданию, по нажатию на элемент списка у нас должно открываться активити с детальной информацией. RecyclerView не предоставляет удобный способ понять на какой элемент списка нажали. Нам необходимо реализовать эту функциональность самостоятельно. Реализуем слушатель нажатия View.OnClickListener в классе ViewHolder и перегрузим метод onClick.

Мы могли бы попытать запускать открытие следующего экрана уже здесь, но это нарушило бы абстракцию. Адаптер не должен ничего знать о других экранах приложения, и тем более брать на себя работу Activity. Мы получим возможность использовать этот адаптер при необходимости и в других местах, когда по клику должно быть совершено другое действие.

Мы можем передавать адаптеру ссылку на активити, и в методе onClick ViewHolder'а вызывать у активити метод стартующий другой экран. Решение уже лучше, но нужно помнить о сокрытии данных. Получая ссылку на активити, в адаптере нам становятся доступны все ее методы.

Решением будет использовать новый тип, под видом которого мы будем передавать ссылку на аквити в адаптер. Создадим интерфейс ItemClickListener, с одним методом - onItemClick. И реализуем этот интерфейс в классе MainActivity.

18. В теле метода onItemClick необходимо будет стартовать DetailedActivity, но поскольку его сейчас нет, для проверки создадим всплывающее сообщение - Toast.
LTKM: Подробнее о Toast: https://developer.android.com/guide/topics/ui/notifiers/toasts.html

19. В адаптере создадим методы setItemClickListener, getItemByPosition.

20. В методе onClick ViewHolder'а, вызовем onItemClick.

21. Возвращаемся в MainActivity и вызываем метод setItemClickListener у адаптера, передав this - ссылку на активити.

22. Создаем новую активити DetailedActivity, при этом не забывая упомянуть о новом экране в манифест файле.

23. Создадим разметку экрана в файле activity_detailed.xml.

24. Вынесем размеры и начертания текста в отдельные стили, в файл styles.xml

25. Вернемся в метод onItemClick, который выполнится по нажатию на элемент списка. Создадим Intent стартующий DetailedActivity. А так же с помощью Intent'а мы передадим в другой экран данные элемента - name и description.
LTKM: Подробнее об Intent https://developer.android.com/reference/android/content/Intent.html .

26. Перейдем в DetailedActivity. В методе onCreate получаем доп. данные, которые содержал Intent, извлекая их по присвоенным именным константам. И инициализируем этими данными вьшки (nameTextView, descriptionTextView).

27. Заверщаюшим шагом будет добавление кнопки "Назад" в тулбаре у DetailedActivity. Сначала в методе onCreate отобразим ее. А дальше - навесим логику закрытия активити, переопределив метод onSupportNavigateUp.
